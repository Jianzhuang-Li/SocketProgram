#include "protcol.h"


uint8_t CRC16_TabH[256] =
{  //CRC
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
  0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
  0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
};
//---------------------------------------------------------------------------------------------------------------------
uint8_t CRC16_TabL[256] =
{  //CRC
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
    0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
    0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
    0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
    0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
    0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
    0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
    0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
    0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
    0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
    0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
    0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
    0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
    0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
    0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
    0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
    0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
    0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};
const char 	hexstring[] = "0123456789ABCDEF";

//数据包索引
//--------------------------------
#define START_FLAG1_LOC     0
#define START_FLAG2_LOC     1
#define COMMAND_LEN_LOC     2
#define COMMAND_TYPE_LOC    3
#define BEGIN_DATA_LOC      4
//--------------------------------

//数据包长度
//--------------------------------
#define HEART_BEAT_RETURN_LENGTH	0x06	//心跳返回包长度
#define HEART_BEAT_LENGTH           0x06    //心跳包长度
#define REGISTER_DEVICE_LONGTH      0x0f    //注册设备数据包长度
#define INQUIRE_PAIR_DEVICE_LENGTH  0x0f    //查询配对设备是否在线数据包长度
//--------------------------------

//指令类型
typedef enum {
	UNDEFINED,
	HEART_BEAT_RETURN               = 0x01,	//心跳返回
    HEART_BEAT                      = 0x02, //心跳包
    REGISTER_DEVICE                 = 0x03, //注册设备
    REGISTER_DEVICE_RETURN          = 0x04, //注册设备返回
    INQUIRE_PAIR_DEVICE             = 0x05, //查询配对设备是否在线
    INQUIRE_PAIR_DEVICE_RETURN      = 0x06, //查询配对设备是否在线返回
    CONTROL_DATA_TO_TARGET_DEVICE   = 0x06, //转发控制信息到目标设备
    CONTROL_DATA                    = 0x07, //控制信息
    
}COM_TYPE;


//CRC校验函数
void CrcCheck(uint8_t* data, size_t length,uint8_t crc_result[]) {
    uint16_t index;
    crc_result[0] = 0xff;
    crc_result[1] = 0xff;
    int i = 0;
    while ((length--) > 0)  //CRC
    {
        index = crc_result[0] ^ data[i++];
        crc_result[0] = (unsigned char)(crc_result[1] ^ CRC16_TabH[index]);
        crc_result[1] = CRC16_TabL[index];
    }
}

//CRC校验对比
bool CompareCmdCRC(char* crc, uint8_t crc_result[]) {
	return ((crc[0] != hexstring[crc_result[0] >> 4]) ||
		(crc[1] != hexstring[crc_result[0] & 0x0F]) ||
		(crc[2] != hexstring[crc_result[1] >> 4]) ||
		(crc[3] != hexstring[crc_result[1] & 0x0F]));
}

//添加CRC校验
uint16_t  AppendCrc(uint8_t* sendbuf) {
    size_t buf_len = 0;
    uint8_t crc_result[8];
    while (*(sendbuf + buf_len)) buf_len++;
    CrcCheck(sendbuf, buf_len,crc_result);
    sendbuf[buf_len] = hexstring[crc_result[0] >> 4];
    sendbuf[buf_len + 1] = hexstring[crc_result[0] & 0x0F];
    sendbuf[buf_len + 2] = hexstring[crc_result[1] >> 4];
    sendbuf[buf_len + 3] = hexstring[crc_result[1] & 0x0F];
    sendbuf[buf_len + 4] = ';';
    sendbuf[buf_len + 5] = '#';
    sendbuf[buf_len + 6] = 0;
    return buf_len + 6;
}

//找到包头并去除包头前的数据
bool LocStartFlagAndRemoveInvalidHead(uint8_t* recvbuff, uint16_t *recv_length) {
	int loc;
	for (loc=0; loc < *recv_length - 1; loc++) {
		if (recvbuff[loc] == 0xFA &&recvbuff[loc + 1] == 0xAF) {
			break;
		}
	}
	if (loc == *recv_length - 1) { //未找到包头
		return false;
	}
	if (loc != 0) {
		for (uint8_t j = loc; j < *recv_length; j++)
			recvbuff[j - loc] = recvbuff[j];
			*recv_length = *recv_length - loc;
	}
	return true;
}

//解析指令
protcolBase* ParseCommand(uint8_t* recvbuff, uint16_t recv_length) {
    uint16_t recv_Length = recv_length;
    uint8_t crc_result[2];
    if (!LocStartFlagAndRemoveInvalidHead(recvbuff, &recv_Length))
        return NULL;   //没有找到包头
    
    size_t comlength = recvbuff[COMMAND_LEN_LOC];
    if (recv_Length < comlength) {
        return NULL;   //字节数不够
    }

    CrcCheck(recvbuff, comlength - 2,crc_result);//CRC校验
    if (recvbuff[comlength - 2] != crc_result[0] || recvbuff[comlength - 1] != crc_result[1]) {
        return NULL;   //CRC校验失败
    }
    
    protcolBase* newMsg = new protcolBase();   //创建一个消息对象
    recvbuff[recv_Length] = '\0';
    string recvbuff_string((char*)recvbuff);
    newMsg->msg_data = recvbuff_string;        //将消息内容填入消息对象
    transObject pFunc = NULL;                  //将消息基类转换为对应的消息子类的指针函数
    protcolPond->findInMap(recvbuff[COMMAND_TYPE_LOC],pFunc);//在消息池中查找该消息，并返回对应的指针函数
    if (pFunc == NULL) return NULL;
    newMsg = pFunc(newMsg);                    //将消息基类对象转换为对应的消息子类对象
    newMsg->unpackMsg();                       //解析消息
    return newMsg;
}

//执行指令,获取需要发送的消息对象
protcolBase* ProcessCommand(protcolBase* newMsg, CClient* pClient) {
    return NULL;
}

//发送心跳返回
/*void SendHeatBeatReturn(CClient* pClient) {
    uint8_t send_buff[MAX_NUM_BUF];
    uint8_t crc_result[2];
    send_buff[0] = 0xFA;
    send_buff[1] = 0xAF;
    send_buff[COMMAND_LEN_LOC] = HEART_BEAT_RETURN_LENGTH;//添加数据包长度
	send_buff[COMMAND_TYPE_LOC] = HEART_BEAT_RETURN;	//添加指令类型
	CrcCheck(send_buff, (size_t)(HEART_BEAT_RETURN_LENGTH - 2), crc_result);	//CRC校验
	send_buff[HEART_BEAT_RETURN_LENGTH - 2] = crc_result[0];  //添加CRC校验
	send_buff[HEART_BEAT_RETURN_LENGTH - 1] = crc_result[1];
	pClient->sendData((char*)send_buff, HEART_BEAT_RETURN_LENGTH);//发送心跳
}*/
void SendHeatBeatReturn(CClient* pClient) {
    HeartBeatReturn heartbeatReturn;
    heartbeatReturn.packMsg();
    protcolBase* pbase = (protcolBase*)&heartbeatReturn;
    pClient->sendData(pbase->msg_data.c_str(), pbase->msg_data.length());
}
